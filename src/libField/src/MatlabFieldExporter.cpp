#include <Field/MatlabFieldExporter.h>
#include <string>

using animesh::MatlabFieldExporter;
using animesh::Field;

/** 
 * Constructor 
 */
MatlabFieldExporter::MatlabFieldExporter( std::ostream& out ) : m_out{ out } {
};

/** 
 * Destructor
 */
MatlabFieldExporter::~MatlabFieldExporter( ) {}


/**
 * Export the field
 */
void MatlabFieldExporter::exportField( const Field& field  ) const {
	writeHeader( m_out );

	const std::vector<FieldElement *>& elements = field.elements(0);

	writeLocationData( m_out, elements );
	writeNormalData( m_out, elements );
	writeTangentData( m_out, elements );
}

/**
 * Level 5 MAT-files begin with a 128-byte header made up of a 124-byte text field and two, 16-bit flag fields.
 */
void MatlabFieldExporter::writeHeader( std::ostream& out ) const {
	char header_text[116];
	for( int i=0; i<116; i++ ) {
		header_text[i] = 0;
	}
	strcpy( header_text, "MATLAB 5.0 MAT-file, Generated by Animesh" );
	out.write( header_text, 116 );	

	// Subsystem specific data
	char sub[] = "\0\0\0\0\0\0\0\0";
	out.write( sub, 8 );	

	writeShort( out, 0x0100 );

	// 'MI'
	writeChar( out, 'M' );
	writeChar( out, 'I' );
}

void MatlabFieldExporter::writeLocationData( std::ostream& out, const std::vector<FieldElement *>& elements ) const {
	using namespace Eigen;
	using namespace std;

	int paddingLength = writeVectorsHeader( out, "location_matrix_", elements.size() );
	for( auto element : elements ) {
		writeVector3f( out, element->location( ) );
	}
	char padding[] = { (char) 0, (char) 0, (char) 0, (char) 0, (char) 0, (char) 0, (char) 0, (char) 0};
	out.write( padding, paddingLength);
}

void MatlabFieldExporter::writeNormalData( std::ostream& out, const std::vector<FieldElement *>& elements ) const {
	using namespace Eigen;
	using namespace std;
	
	int paddingLength = writeVectorsHeader( out, "normal_matrix___", elements.size() );
	for( auto element : elements ) {
		writeVector3f( out, element->normal() );
	}
	char padding[] = { (char) 0, (char) 0, (char) 0, (char) 0, (char) 0, (char) 0, (char) 0, (char) 0};
	out.write( padding, paddingLength);
}

void MatlabFieldExporter::writeTangentData( std::ostream& out, const std::vector<FieldElement *>& elements ) const {
	using namespace Eigen;
	using namespace std;
	
	int paddingLength = writeVectorsHeader( out, "tangent_matrix__", elements.size() );
	for( auto element : elements ) {
		writeVector3f( out, element->tangent() );
	}
	char padding[] = { (char) 0, (char) 0, (char) 0, (char) 0, (char) 0, (char) 0, (char) 0, (char) 0};
	out.write( padding, paddingLength);
}

void MatlabFieldExporter::writeInt( std::ostream& out, int i ) const {
	out.write( reinterpret_cast<char*>(&i), 4 );
}
void MatlabFieldExporter::writeShort( std::ostream& out, short s ) const {
	out.write( reinterpret_cast<char*>(&s), 2 );
}
void MatlabFieldExporter::writeChar( std::ostream& out, char c ) const {
    out.write( reinterpret_cast<char*>(&c), 1 );
}
void MatlabFieldExporter::writeVector3f( std::ostream& out, const Eigen::Vector3f& vector ) const {
	out.write( reinterpret_cast<const char*>( &(vector[0]) ), sizeof( float ) );
	out.write( reinterpret_cast<const char*>( &(vector[1]) ), sizeof( float ) );
	out.write( reinterpret_cast<const char*>( &(vector[2]) ), sizeof( float ) );
}
/**
 * Write the header for a vector
 */
int MatlabFieldExporter::writeVectorsHeader( std::ostream& out, const char * const name,  unsigned int numVectors ) const {
	
	// Write the array header
	writeInt( out, 14 );					// miMATRIX
	int matrix_size_bytes = 4 + 4 + 8 +		 		// ArrayFlags
							4 + 4 + 8 +				// miINT32 plus 2 * 4 (dimensions)
							4 + 4 + strlen(name)+ 	// miINT8
							4 + 4 + numVectors * 3 * 4; // miSINGLE

	// We may need to pad to a multiple of 8 bytes
	int padding = 8 - (matrix_size_bytes % 8);
	if( padding == 8 ) padding = 0;
	matrix_size_bytes += padding;

	writeInt( out, matrix_size_bytes);

	// Array Flags
	writeInt( out, 6 );		// miUINT32
	writeInt( out, 8 );		// 2 of above

	writeInt( out, 0x00000407 );
	writeInt( out, 0 );

	// Write dimensions
	writeInt( out, 5 );		// miINT32
	writeInt( out, 8 );		// 2 of
	writeInt( out, 3 );
	writeInt( out, numVectors );

	// Write name
	writeInt( out, 1 );						// miINT8
	writeInt( out, strlen( name ) );		// length of name
	out.write ( name, strlen( name ) );		// data

	// Real Part will be written by something else
	writeInt( out, 7 ); 					// miSINGLE
	writeInt( out, numVectors * 3 * 4 ); 	// length

	return padding;
}